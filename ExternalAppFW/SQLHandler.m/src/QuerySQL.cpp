//===================================================================
// COPYRIGHT Tony 2016/11/21
//===================================================================
// QuerySQL.cpp
// Header definition of class QuerySQL
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2016/11/21 Creation: Code generated by the 3DS wizard
//===================================================================
#include <iostream>
using std::cout;
using std::endl;

#include "QuerySQL.h"
#include "CATBSTRDef.h"

HRESULT ExecuteSQLCommand(const CATUnicodeString &strSQLCmdText)
{
	HRESULT rc = S_OK;
	if (0 == strSQLCmdText.GetLengthInChar())
	{
		rc = E_FAIL;
		return rc;
	}

	::CoInitialize(NULL);

	_ConnectionPtr pConnection = NULL;
	_RecordsetPtr pRecordSetPtr = NULL;

	//step 1:create the Connection Object
	if (SUCCEEDED(rc) && NULL == pConnection)
		rc = pConnection.CreateInstance(__uuidof(Connection));

	if (SUCCEEDED(rc) && adStateOpen != pConnection->GetState())
	{
		pConnection->ConnectionTimeout = 10;
		rc = pConnection->Open(SQLConnectionString,"","",adModeUnknown); // Ê¹ÓÃadModeReadWrite³ö´í£¿
	}

	//=============================Excute without recordset  
	try{
		CATBSTR bstrSQLCmdText = (_bstr_t)"";
		strSQLCmdText.ConvertToBSTR(&bstrSQLCmdText);
		pConnection->Execute(bstrSQLCmdText,NULL,adCmdText);
	}
	catch(_com_error e)
	{
		rc = E_FAIL;
		cout<<e.Description()<<endl;
	}
	
	// close
	if(NULL != pConnection && adStateOpen == pConnection->GetState()) 
		pConnection->Close(); 

	pRecordSetPtr = NULL;
	pConnection = NULL; 
	::CoUninitialize();

	return rc;
}



HRESULT ExecuteSQLCommand(const CATUnicodeString &strSQLCmdText, vector<vector<CATUnicodeString>> &strVv, vector<CATUnicodeString> &strTitle)
{
	// Initialize
	HRESULT rc = S_OK;
	if (0 == strSQLCmdText.GetLengthInChar())
	{
		rc = E_FAIL;
		return rc;
	}

	strVv.clear();
	::CoInitialize(NULL);

	_ConnectionPtr pConnection = NULL;
	_RecordsetPtr pRecordSetPtr = NULL;

	// create the Connection Object
	if (SUCCEEDED(rc) && NULL == pConnection)
		rc = pConnection.CreateInstance(__uuidof(Connection));

	if (SUCCEEDED(rc) && adStateOpen != pConnection->GetState())
	{
		pConnection->ConnectionTimeout = 10;
		rc = pConnection->Open(SQLConnectionString,"","",adModeUnknown);
	}

	// Put the result into double dimension vector
	if (SUCCEEDED(rc))
	{
		CATBSTR bstrSQLCmdText = (_bstr_t)"";
		strSQLCmdText.ConvertToBSTR(&bstrSQLCmdText);
		if (SUCCEEDED(pRecordSetPtr.CreateInstance(__uuidof(Recordset))))
		{
			try
			{
				rc = pRecordSetPtr->Open((_bstr_t)bstrSQLCmdText,pConnection.GetInterfacePtr(),adOpenKeyset,adLockOptimistic,adCmdText);
				pRecordSetPtr->MoveFirst();
				while (!pRecordSetPtr->adoEOF)
				{
					vector<CATUnicodeString> vStrValue;
					for (auto iterator_Title = strTitle.begin(); iterator_Title != strTitle.end(); iterator_Title++)
					{
						CATUnicodeString strValue = CATUnicodeString((LPSTR)_bstr_t(pRecordSetPtr->GetCollect((*iterator_Title).ConvertToChar())));
						vStrValue.push_back(strValue);
					}
					strVv.push_back(vStrValue);
					pRecordSetPtr->MoveNext();
				}
			}
			catch(_com_error e)
			{
				rc = E_FAIL;
				cout<<e.Description()<<endl;
			}
		}
		else
			rc = E_FAIL;
	}

	// close
	if(NULL != pConnection && adStateOpen == pConnection->GetState()) 
		pConnection->Close(); 

	pRecordSetPtr = NULL;
	pConnection = NULL; 
	::CoUninitialize();

	return rc;
}