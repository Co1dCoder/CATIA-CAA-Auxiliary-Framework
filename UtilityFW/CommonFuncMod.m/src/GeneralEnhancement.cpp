//===================================================================
// COPYRIGHT Tony 2017/03/24
//===================================================================
// GeneralEnhancement.cpp
// Header definition of class GeneralEnhancement
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2017/03/24 Creation: Code generated by the 3DS wizard
//===================================================================

#include "GeneralEnhancement.h"

#include <tchar.h>
#include "CATListOfInt.h"
#include "CATIAdpPLMIdentificator.h"
#include "CATIPLMComponent.h"
#include "CATICkeObject.h"
#include "CATIPLMNavReference.h"
#include "CATCkeObjectAttrReadServices.h"
#include "CATAdpQueryServices.h"
#include "CATPLMBatch.h"
#include "CATStdIO.h"
#include "CATIXMLDOMDocumentBuilder.h"
#include "CATIDOMDocument.h"
#include "CATIXMLXPathFactory.h"
#include "CATIXMLXPathExpression.h"
#include "CATIDOMElement.h"
#include "CATIDOMNodeList.h"
#include "CATIDOMText.h"
#include "CATVisPropertiesValues.h"
#include "CATShowAttribut.h"
#include "CATIVisProperties.h"
#include "CATIModelEvents.h"
#include "CATModifyVisProperties.h"
#include "CATToken.h"
#include "CATIAlias.h"

namespace JNCTonySpace{

HRESULT GetFilePathFromEnv(CATUnicodeString iResourceWord,CATUnicodeString iFileName,CATUnicodeString &oPath)
{
	oPath = "";
	char* pEnvValuePath = NULL;
	HRESULT rc = E_FAIL;

	CATLibStatus result=::CATGetEnvValue(iResourceWord, &pEnvValuePath);
	if((result==CATLibError)||(pEnvValuePath==NULL))
	{
		return rc;
	}

	CATUnicodeString CAAEnvPath;
	//CAAEnvPath = CATFindPath(iFileName,pEnvValuePath); // this method can only be used for search directory, not for file
	CAAEnvPath = pEnvValuePath;
	free (pEnvValuePath) ;

	CATToken Token(CAAEnvPath,FALSE);
	CATUnicodeString eachToken = "";
	CATUnicodeString eachPath = "";
	bool bFlag = false;
	while(true) 
	{
		eachToken = Token.GetNextToken(";");
		if (eachToken.GetLengthInChar() == 0)
			break;

		eachPath = eachToken + "\\"+iFileName;
		if( (_access(eachPath.ConvertToChar(), 0 )) != -1 )
		{
			oPath = eachPath;
			rc = S_OK;
			break;
		}
	} 

	return rc;
}

void MyMsgBox( CATUnicodeString iMessage, MsgboxType MsgType)
{
	if (0 == MsgType)
	{
		CATDlgNotify *pDlgNy = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(),"Msg",CATDlgNfyInformation|CATDlgNfyOK);

		int iRet = pDlgNy->DisplayBlocked(iMessage, "Í¨Öª"); // notify
		if(1 == iRet)
		{
			pDlgNy->RequestDelayedDestruction();
			pDlgNy = NULL;
		}
	}

	if (1 == MsgType)
	{
		CATDlgNotify *pDlgNy = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(),"Msg",CATDlgNfyWarning|CATDlgNfyOK);

		int iRet = pDlgNy->DisplayBlocked(iMessage, "¾¯¸æ"); // warn
		if(1 == iRet)
		{
			pDlgNy->RequestDelayedDestruction();
			pDlgNy = NULL;
		}
	}

	if (2 == MsgType)
	{
		CATDlgNotify *pDlgNy = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(),"Msg",CATDlgNfyError|CATDlgNfyOK);

		int iRet = pDlgNy->DisplayBlocked(iMessage, "´íÎó"); //error
		if(1 == iRet)
		{
			pDlgNy->RequestDelayedDestruction();
			pDlgNy = NULL;
		}
	}

	return;
}

HRESULT GetPathString(CATPathElement * ipPath, CATUnicodeString & oPathString)
{
	oPathString = oPathString.SubString(0,oPathString.GetLengthInChar()-1);*/

	oPathString = "" ;
	if ( NULL != ipPath )
	{
		int sizeOfThePath = ipPath->GetSize();  

		for ( int i = 0 ; i < sizeOfThePath ; i++ )
		{
			CATBaseUnknown * pElt = (*ipPath)[i] ;
			if ( NULL != pElt )
			{
				CATIAlias_var spAliasOnElt = NULL_var;
				spAliasOnElt = pElt;
				if (!!spAliasOnElt)
				{
					CATUnicodeString Name = spAliasOnElt->GetAlias();
					oPathString.Append(Name) ;	
				}
				else
					oPathString.Append("NoAlias") ;					
			}
			else
				oPathString.Append("NULL"); ;

			if ( i <= (sizeOfThePath-2) )
				oPathString.Append("/"); 			
		}
	}

	return S_OK;
}

void ExecuteShell( const CATUnicodeString iFileFullPath, const CATUnicodeString iParamStr, CATBoolean iIsWaited, HANDLE * opProcess )
{
	SHELLEXECUTEINFO shExeInfo = {0};
	shExeInfo.cbSize = sizeof(SHELLEXECUTEINFO);
	shExeInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shExeInfo.hwnd = NULL;
	shExeInfo.lpVerb = _T("open");
	shExeInfo.lpFile = iFileFullPath;
	if(iParamStr.GetLengthInChar() > 0)
		shExeInfo.lpParameters = iParamStr;
	shExeInfo.lpDirectory = NULL;
	shExeInfo.nShow = SW_HIDE;
	shExeInfo.hInstApp = NULL;
	ShellExecuteEx(&shExeInfo);
	if(opProcess)
		* opProcess = shExeInfo.hProcess;
	if(iIsWaited)
		WaitForSingleObject(shExeInfo.hProcess, INFINITE);
}

HRESULT GetRegValue( HKEY iHKey, const CATUnicodeString &iPath, const CATUnicodeString &iName, DWORD iType, CATUnicodeString &oValue )
{
	HRESULT rc = E_FAIL;
	HKEY hKey;
	WCHAR pathContentW[MAX_PATH];
	iPath.ConvertToWChar(pathContentW);
	if(ERROR_SUCCESS == RegOpenKeyExW(iHKey, pathContentW, 0, KEY_READ, &hKey))
	{
		WCHAR itemNameW[MAX_PATH];
		iName.ConvertToWChar(itemNameW);
		if(iType == REG_SZ)
		{
			WCHAR szBuffer[MAX_PATH];
			DWORD dwBufferSize = sizeof(szBuffer);
			if(ERROR_SUCCESS == RegQueryValueExW(hKey, itemNameW, 0, 0, (LPBYTE)szBuffer, &dwBufferSize))
			{
				std::wstring wPath = szBuffer;
				std::string sPath(wPath.begin(), wPath.end());
				oValue = sPath.c_str();
				rc = S_OK;
			}
		}
		else if(iType == REG_DWORD)
		{
			ULONG value;
			DWORD dwBufferSize = sizeof(DWORD);
			if(ERROR_SUCCESS == RegQueryValueExW(hKey, itemNameW, 0, &iType, (LPBYTE)&value, &dwBufferSize))
			{
				oValue.BuildFromNum(value);
				rc = S_OK;
			}
		}
	}
	return rc;
}

void HideObject( CATBaseUnknown_var ispObj, CATBoolean bShow /*= FALSE*/ )
{
	CATVisPropertiesValues ioValues;
	CATShowAttribut oShow;
	if(bShow)
		oShow=CATShowAttr;
	else
		oShow=CATNoShowAttr;

	ioValues.SetShowAttr(oShow);

	CATIVisProperties_var spVisProp = ispObj;
	if(NULL_var != spVisProp)
		spVisProp->SetPropertiesAtt(ioValues,CATVPShow,CATVPGlobalType);
	
	CATIModelEvents_var spEvents = ispObj;
	if (NULL_var != spEvents)
	{
		CATModifyVisProperties ModifyNotification(ispObj, NULL, CATVPGlobalType, CATVPShow, ioValues); 
		spEvents->Dispatch(ModifyNotification);
	}
}

void GetMultiListSelectedRowID( CATDlgMultiList* iDlgList, std::vector<int>& ioListIdx )
{
	if (NULL == iDlgList)
		return ;

	ioListIdx.clear();
	int iSize_SelectedItem = iDlgList->GetSelectCount();
	if (iSize_SelectedItem > 0)
	{
		int *pArr_SelectedItemIndex = new int[iSize_SelectedItem];
		iDlgList->GetSelect(pArr_SelectedItemIndex,iSize_SelectedItem);
		for (int i = 0; i < iSize_SelectedItem; i++)
			ioListIdx.push_back(pArr_SelectedItemIndex[i]);

		delete[] pArr_SelectedItemIndex;
	}
}

}



